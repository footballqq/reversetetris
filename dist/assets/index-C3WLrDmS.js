var Y=Object.defineProperty;var N=(h,t,e)=>t in h?Y(h,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):h[t]=e;var n=(h,t,e)=>N(h,typeof t!="symbol"?t+"":t,e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))i(s);new MutationObserver(s=>{for(const a of s)if(a.type==="childList")for(const o of a.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&i(o)}).observe(document,{childList:!0,subtree:!0});function e(s){const a={};return s.integrity&&(a.integrity=s.integrity),s.referrerPolicy&&(a.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?a.credentials="include":s.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function i(s){if(s.ep)return;s.ep=!0;const a=e(s);fetch(s.href,a)}})();const f=class f{constructor(t){n(this,"_grid");t?this._grid=t.map(e=>[...e]):this._grid=Array.from({length:f.TOTAL_ROWS},()=>Array(f.WIDTH).fill(0))}get data(){return this._grid}isCellEmpty(t,e){return t<0||t>=f.WIDTH||e>=f.TOTAL_ROWS?!1:e<0?!0:this._grid[e][t]===0}isValidPosition(t,e,i){for(const s of t){const a=e+s.x,o=i+s.y;if(a<0||a>=f.WIDTH||o>=f.TOTAL_ROWS||o>=0&&this._grid[o][a]!==0)return!1}return!0}lockPiece(t,e,i,s){for(const a of t){const o=e+a.x,c=i+a.y;o>=0&&o<f.WIDTH&&c>=0&&c<f.TOTAL_ROWS&&(this._grid[c][o]=s)}}clearLines(){let t=0;for(let e=f.TOTAL_ROWS-1;e>=0;e--)this.isRowFull(e)&&(this.removeRow(e),t++,e++);return t}isRowFull(t){return this._grid[t].every(e=>e!==0)}removeRow(t){this._grid.splice(t,1),this._grid.unshift(Array(f.WIDTH).fill(0))}isGameOver(){return this._grid[0].some(t=>t!==0)||this._grid[1].some(t=>t!==0)}getHeight(){for(let t=0;t<f.TOTAL_ROWS;t++)if(this._grid[t].some(e=>e!==0))return f.TOTAL_ROWS-t;return 0}countHoles(){let t=0;for(let e=0;e<f.WIDTH;e++){let i=!1;for(let s=0;s<f.TOTAL_ROWS;s++)this._grid[s][e]!==0?i=!0:i&&this._grid[s][e]===0&&t++}return t}countBlockades(){let t=0;for(let e=0;e<f.WIDTH;e++){let i=!1;for(let s=f.TOTAL_ROWS-1;s>=0;s--)this._grid[s][e]===0?i=!0:i&&t++}return t}getWellSums(){let t=0;for(let e=0;e<f.WIDTH;e++){let i=0;for(let s=0;s<f.TOTAL_ROWS;s++){if(this._grid[s][e]!==0){i=0;continue}const a=e===0?!0:this._grid[s][e-1]!==0,o=e===f.WIDTH-1?!0:this._grid[s][e+1]!==0;a&&o?(i+=1,t+=i):i=0}}return t}getAggregateHeight(){let t=0;for(let e=0;e<f.WIDTH;e++)for(let i=0;i<f.TOTAL_ROWS;i++)if(this._grid[i][e]!==0){t+=f.TOTAL_ROWS-i;break}return t}getBumpiness(){let t=0,e=this.getColumnHeight(0);for(let i=1;i<f.WIDTH;i++){const s=this.getColumnHeight(i);t+=Math.abs(e-s),e=s}return t}getColumnHeight(t){for(let e=0;e<f.TOTAL_ROWS;e++)if(this._grid[e][t]!==0)return f.TOTAL_ROWS-e;return 0}clone(){const t=new f;return t._grid=this._grid.map(e=>[...e]),t}};n(f,"WIDTH",10),n(f,"HEIGHT",20),n(f,"TOTAL_ROWS",22),n(f,"VISIBLE_ROWS",20);let v=f;var u=(h=>(h.I="I",h.O="O",h.T="T",h.S="S",h.Z="Z",h.J="J",h.L="L",h.LONG_I="LONG_I",h.CROSS="CROSS",h.SQUARE_HOLLOW="SQUARE_HOLLOW",h))(u||{});const X={[u.I]:[[[-1,0],[0,0],[1,0],[2,0]],[[1,-1],[1,0],[1,1],[1,2]],[[-1,1],[0,1],[1,1],[2,1]],[[0,-1],[0,0],[0,1],[0,2]]],[u.O]:[[[0,0],[1,0],[0,1],[1,1]],[[0,0],[1,0],[0,1],[1,1]],[[0,0],[1,0],[0,1],[1,1]],[[0,0],[1,0],[0,1],[1,1]]],[u.T]:[[[0,-1],[-1,0],[0,0],[1,0]],[[0,-1],[0,0],[1,0],[0,1]],[[-1,0],[0,0],[1,0],[0,1]],[[0,-1],[-1,0],[0,0],[0,1]]],[u.S]:[[[0,-1],[1,-1],[-1,0],[0,0]],[[0,-1],[0,0],[1,0],[1,1]],[[0,0],[1,0],[-1,1],[0,1]],[[-1,-1],[-1,0],[0,0],[0,1]]],[u.Z]:[[[-1,-1],[0,-1],[0,0],[1,0]],[[1,-1],[0,0],[1,0],[0,1]],[[-1,0],[0,0],[0,1],[1,1]],[[0,-1],[-1,0],[0,0],[-1,1]]],[u.J]:[[[-1,-1],[-1,0],[0,0],[1,0]],[[0,-1],[1,-1],[0,0],[0,1]],[[-1,0],[0,0],[1,0],[1,1]],[[0,-1],[0,0],[-1,1],[0,1]]],[u.L]:[[[1,-1],[-1,0],[0,0],[1,0]],[[0,-1],[0,0],[0,1],[1,1]],[[-1,0],[0,0],[1,0],[-1,1]],[[-1,-1],[0,-1],[0,0],[0,1]]],[u.LONG_I]:[[[-2,0],[-1,0],[0,0],[1,0],[2,0],[3,0]],[[0,-2],[0,-1],[0,0],[0,1],[0,2],[0,3]],[[-2,0],[-1,0],[0,0],[1,0],[2,0],[3,0]],[[0,-2],[0,-1],[0,0],[0,1],[0,2],[0,3]]],[u.CROSS]:[[[0,-1],[-1,0],[0,0],[1,0],[0,1]],[[0,-1],[-1,0],[0,0],[1,0],[0,1]],[[0,-1],[-1,0],[0,0],[1,0],[0,1]],[[0,-1],[-1,0],[0,0],[1,0],[0,1]]],[u.SQUARE_HOLLOW]:[[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]],[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]],[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]],[[-1,-1],[0,-1],[1,-1],[-1,0],[1,0],[-1,1],[0,1],[1,1]]]},F={[u.I]:"#00f0f0",[u.O]:"#f0f000",[u.T]:"#a000f0",[u.S]:"#00f000",[u.Z]:"#f00000",[u.J]:"#0000f0",[u.L]:"#f0a000",[u.LONG_I]:"#FFD700",[u.CROSS]:"#FFD700",[u.SQUARE_HOLLOW]:"#FFD700"},B={[u.I]:1,[u.O]:2,[u.T]:3,[u.S]:4,[u.Z]:5,[u.J]:6,[u.L]:7,[u.LONG_I]:8,[u.CROSS]:8,[u.SQUARE_HOLLOW]:8},U={1:"#00f0f0",2:"#f0f000",3:"#a000f0",4:"#00f000",5:"#f00000",6:"#0000f0",7:"#f0a000",8:"#FFD700"};class z{constructor(){n(this,"particles",[]);n(this,"texts",[]);n(this,"shakeX",0);n(this,"shakeY",0);n(this,"shakeTime",0)}update(t){if(this.particles=this.particles.filter(e=>(e.x+=e.vx*(t/16),e.y+=e.vy*(t/16),e.life-=t,e.life>0)),this.texts=this.texts.filter(e=>(e.y+=e.vy*(t/16),e.life-=t,e.life>0)),this.shakeTime>0){this.shakeTime-=t;const e=Math.min(10,this.shakeTime/20);this.shakeX=(Math.random()-.5)*e,this.shakeY=(Math.random()-.5)*e}else this.shakeX=0,this.shakeY=0}draw(t){this.particles.forEach(e=>{t.globalAlpha=e.life/e.maxLife,t.fillStyle=e.color,t.fillRect(e.x,e.y,e.size,e.size)}),t.globalAlpha=1,this.texts.forEach(e=>{t.globalAlpha=e.life/e.maxLife,t.fillStyle=e.color,t.font="bold 20px Arial",t.fillText(e.text,e.x,e.y)}),t.globalAlpha=1}getShake(){return{x:this.shakeX,y:this.shakeY}}spawnParticles(t,e,i,s=10){for(let a=0;a<s;a++)this.particles.push({x:t,y:e,vx:(Math.random()-.5)*5,vy:(Math.random()-.5)*5,life:500+Math.random()*500,maxLife:1e3,color:i,size:2+Math.random()*3})}spawnText(t,e,i,s="#fff"){this.texts.push({x:t,y:e,text:i,color:s,life:1e3,maxLife:1e3,vy:-1})}triggerShake(t=200){this.shakeTime=t}}class q{constructor(t){n(this,"canvas");n(this,"ctx");n(this,"width",800);n(this,"height",600);n(this,"animator");n(this,"layout",{cellSize:24,gridX:0,gridY:0,gridWidth:0,gridHeight:0,selectionY:20,selectionHeight:80,selectionX:0,slotWidth:0,isPortrait:!1});n(this,"VISIBLE_START_ROW",2);this.canvas=t,this.ctx=t.getContext("2d"),this.animator=new z,this.handleResize(),window.addEventListener("resize",()=>this.handleResize())}handleResize(){const t=window.devicePixelRatio||1;this.width=window.innerWidth,this.height=window.innerHeight,this.canvas.width=this.width*t,this.canvas.height=this.height*t,this.ctx.setTransform(1,0,0,1,0,0),this.ctx.scale(t,t),this.recalculateLayout()}recalculateLayout(){const t=v.WIDTH,e=v.TOTAL_ROWS-this.VISIBLE_START_ROW,i=this.height>this.width;if(this.layout.isPortrait=i,this.layout.selectionHeight=70,i){this.layout.selectionY=10;const s=this.layout.selectionY+this.layout.selectionHeight+10,a=this.height-s-60,o=this.width-20,c=Math.floor(a/e),l=Math.floor(o/t);let r=Math.min(c,l);r=Math.min(r,35),r=Math.max(r,12),this.layout.cellSize=r,this.layout.gridWidth=t*r,this.layout.gridHeight=e*r,this.layout.gridX=Math.floor((this.width-this.layout.gridWidth)/2),this.layout.gridY=s}else{this.layout.selectionY=15;const s=this.width-200,a=this.height-130,o=Math.floor(a/e),c=Math.floor(s/t);let l=Math.min(o,c);l=Math.min(l,30),l=Math.max(l,15),this.layout.cellSize=l,this.layout.gridWidth=t*l,this.layout.gridHeight=e*l,this.layout.gridX=Math.floor((this.width-this.layout.gridWidth)/2)-60,this.layout.gridY=110}this.layout.selectionX=this.layout.gridX,this.layout.slotWidth=this.layout.gridWidth/3}clear(){this.ctx.fillStyle="#1a1a1a",this.ctx.fillRect(0,0,this.width,this.height),this.animator.draw(this.ctx)}update(t){this.animator.update(t)}drawAnimations(){this.animator.draw(this.ctx)}drawGrid(t){const e=this.animator.getShake();this.ctx.save(),this.ctx.translate(e.x,e.y),this.ctx.fillStyle="#111",this.ctx.fillRect(this.layout.gridX,this.layout.gridY,this.layout.gridWidth,this.layout.gridHeight),this.ctx.strokeStyle="#333",this.ctx.lineWidth=1,this.ctx.beginPath();for(let s=0;s<=v.WIDTH;s++){const a=this.layout.gridX+s*this.layout.cellSize;this.ctx.moveTo(a,this.layout.gridY),this.ctx.lineTo(a,this.layout.gridY+this.layout.gridHeight)}for(let s=0;s<=v.TOTAL_ROWS-this.VISIBLE_START_ROW;s++){const a=this.layout.gridY+s*this.layout.cellSize;this.ctx.moveTo(this.layout.gridX,a),this.ctx.lineTo(this.layout.gridX+this.layout.gridWidth,a)}this.ctx.stroke(),this.ctx.strokeStyle="#fff",this.ctx.lineWidth=2,this.ctx.strokeRect(this.layout.gridX-2,this.layout.gridY-2,this.layout.gridWidth+4,this.layout.gridHeight+4);const i=t.data;for(let s=this.VISIBLE_START_ROW;s<v.TOTAL_ROWS;s++)for(let a=0;a<v.WIDTH;a++){const o=i[s][a],c=U[o];o!==0&&c&&this.drawCell(this.layout.gridX+a*this.layout.cellSize,this.layout.gridY+(s-this.VISIBLE_START_ROW)*this.layout.cellSize,c)}this.ctx.restore()}drawPiece(t,e,i,s){const a=this.animator.getShake();this.ctx.save(),this.ctx.translate(a.x,a.y);const o=t.getBlocks(s),c=t.getColor();for(const l of o){const r=this.layout.gridX+(e+l.x)*this.layout.cellSize,g=this.layout.gridY+(i+l.y-this.VISIBLE_START_ROW)*this.layout.cellSize;i+l.y>=this.VISIBLE_START_ROW&&this.drawCell(r,g,c)}this.ctx.restore()}drawGhostPiece(t,e,i,s){const a=this.animator.getShake();this.ctx.save(),this.ctx.translate(a.x,a.y),this.ctx.globalAlpha=.3;const o=t.getBlocks(s),c=t.getColor();for(const l of o){const r=this.layout.gridX+(e+l.x)*this.layout.cellSize,g=this.layout.gridY+(i+l.y-this.VISIBLE_START_ROW)*this.layout.cellSize;i+l.y>=this.VISIBLE_START_ROW&&this.drawCell(r,g,c,!0)}this.ctx.globalAlpha=1,this.ctx.restore()}drawCell(t,e,i,s=!1){const a=this.layout.cellSize-2;if(this.ctx.fillStyle=i,this.ctx.fillRect(t+1,e+1,a,a),s||(this.ctx.fillStyle="rgba(255,255,255,0.3)",this.ctx.fillRect(t+1,e+1,a,a/3)),!s&&i==="#FFD700"){const o=performance.now()/500,c=(Math.sin(o)+1)/2*.4+.1;this.ctx.save(),this.ctx.strokeStyle=`rgba(255, 255, 200, ${c})`,this.ctx.lineWidth=2,this.ctx.shadowBlur=10,this.ctx.shadowColor="#FFD700",this.ctx.strokeRect(t+2,e+2,a-2,a-2),this.ctx.restore()}}drawPieceSelector(t,e){this.ctx.strokeStyle="#fff",this.ctx.lineWidth=2,this.ctx.strokeRect(this.layout.selectionX-2,this.layout.selectionY-2,this.layout.gridWidth+4,this.layout.selectionHeight+4),this.ctx.fillStyle="#aaa",this.ctx.font="12px Arial",this.ctx.textAlign="left",this.ctx.fillText("CANDIDATES",this.layout.selectionX,this.layout.selectionY-8);const i=this.layout.slotWidth;t.forEach((s,a)=>{const o=this.layout.selectionX+a*i+i/2,c=this.layout.selectionY+this.layout.selectionHeight/2;a===e&&(this.ctx.fillStyle="rgba(255,255,255,0.1)",this.ctx.fillRect(this.layout.selectionX+a*i,this.layout.selectionY,i,this.layout.selectionHeight));const l=s.getBlocks(),r=s.getColor();for(const g of l)this.drawCell(o+g.x*this.layout.cellSize-this.layout.cellSize/2,c+g.y*this.layout.cellSize-this.layout.cellSize/2,r);this.ctx.fillStyle="#888",this.ctx.font="10px Arial",this.ctx.textAlign="center",this.ctx.fillText(`${a+1}`,o,this.layout.selectionY+this.layout.selectionHeight-5)})}drawUI(t,e,i,s,a,o,c){this.ctx.textAlign="left",this.ctx.font="12px Arial";let l,r;if(this.layout.isPortrait)l=this.layout.gridX,r=this.layout.gridY+this.layout.gridHeight+20,this.drawText("SCORE",l,r,12,"#aaa"),this.drawText(`${t}`,l,r+20,20,"#fff"),this.drawText("LEVEL",l+100,r,12,"#aaa"),this.drawText(`${e}`,l+100,r+20,20,"#fff"),this.drawText("AI LINES",l+200,r,12,"#aaa"),this.drawText(`${i}/${s}`,l+200,r+20,20,"#fff"),a&&(this.drawText("DIFF",l+300,r,12,"#aaa"),this.drawText(`${a.toUpperCase()}`,l+300,r+20,18,"#fff")),o&&(this.drawText("WELLS",l+420,r,12,"#aaa"),this.drawText(`${o.wellSums}`,l+420,r+20,18,"#fff"),this.drawText("HOLES",l+470,r,12,"#aaa"),this.drawText(`${o.holes}`,l+470,r+20,18,"#fff")),c&&(this.drawText("VER",l+520,r,12,"#666"),this.drawText(c,l+520,r+20,12,"#888"));else{l=this.layout.gridX+this.layout.gridWidth+20,r=this.layout.gridY;const g=this.layout.gridY+this.layout.gridHeight;if(this.drawText("SCORE",l,r+20,14,"#aaa"),this.drawText(`${t}`,l,r+50,24,"#fff"),this.drawText("LEVEL",l,r+100,14,"#aaa"),this.drawText(`${e}`,l,r+130,24,"#fff"),this.drawText("AI LINES",l,r+180,14,"#aaa"),this.drawText(`${i}/${s}`,l,r+210,24,"#fff"),a&&(this.drawText("DIFFICULTY",l,r+250,14,"#aaa"),this.drawText(`${a.toUpperCase()}`,l,r+280,22,"#fff")),o){const T=r+320;this.drawText(`HOLES ${o.holes} (+${o.holesCreated})`,l,T,14,"#aaa"),this.drawText(`BLOCK ${o.blockades}   WELLS ${o.wellSums}`,l,T+24,14,"#aaa"),o.lastMove&&this.drawText(`PRED H${o.lastMove.holes} (+${o.lastMove.holesCreated}) B${o.lastMove.blockades} W${o.lastMove.wellSums} L${o.lastMove.linesCleared}`,l,T+48,12,"#888")}c&&this.drawText(c,l,g-18,12,"#666"),this.drawText("D:DEBUG  V:VERSION  S:LOG",l,g-2,12,"#555")}}drawText(t,e,i,s=30,a="#fff",o="left"){this.ctx.fillStyle=a,this.ctx.font=`${s}px Arial`,this.ctx.textAlign=o,this.ctx.fillText(t,e,i)}}class H{constructor(t){n(this,"type");n(this,"_rotation");this.type=t,this._rotation=0}get rotation(){return this._rotation}rotateClockwise(){this._rotation=(this._rotation+1)%4}rotateCounterClockwise(){this._rotation=(this._rotation+3)%4}setRotation(t){this._rotation=t%4}getBlocks(t){const e=t!==void 0?t%4:this._rotation;return X[this.type][e].map(([a,o])=>({x:a,y:o}))}getColor(){return F[this.type]}clone(){const t=new H(this.type);return t.setRotation(this._rotation),t}}class G{static createRandom(){if(Math.random()<.01){const e=[u.LONG_I,u.CROSS,u.SQUARE_HOLLOW],i=e[Math.floor(Math.random()*e.length)];return new H(i)}this.bag.length===0&&this.refillBag();const t=this.bag.pop();return new H(t)}static createRandomSet(t){const e=[];for(let i=0;i<t;i++)e.push(this.createRandom());return e}static refillBag(){this.bag=[...this.types];for(let t=this.bag.length-1;t>0;t--){const e=Math.floor(Math.random()*(t+1));[this.bag[t],this.bag[e]]=[this.bag[e],this.bag[t]]}}}n(G,"types",[u.I,u.O,u.T,u.S,u.Z,u.J,u.L]),n(G,"bag",[]);const E={EASY:{heightWeight:-.3,linesWeight:.5,holesWeight:-.5,bumpinessWeight:-.2,randomFactor:.3},NORMAL:{heightWeight:-.51,linesWeight:.76,holesWeight:-.36,bumpinessWeight:-.18,randomFactor:0},HARD:{heightWeight:-.51,linesWeight:.76,holesWeight:-.36,bumpinessWeight:-.18,lookahead:1},GOD:{heightWeight:-.6,linesWeight:2.5,holesWeight:-.9,wellsWeight:-.25,bumpinessWeight:-.22,lexicographic:!0,preferEdges:!0}};class Q{constructor(){n(this,"traceEnabled",!1);n(this,"traceTopK",12);n(this,"lastTrace",null)}setTraceEnabled(t,e=12){this.traceEnabled=t,this.traceTopK=Math.max(1,Math.min(50,Math.floor(e))),t||(this.lastTrace=null)}getLastTrace(){return this.lastTrace}findBestMove(t,e,i){let s=-1/0,a=null,o=null;const c=this.traceEnabled?[]:[],l=this.traceEnabled||(i.lexicographic??!1)?this.computeHoleMap(t):this.computeHoleMap(t);for(let r=0;r<4;r++){const g=e.clone();g.setRotation(r);const T=g.getBlocks();for(let L=-2;L<v.WIDTH+2;L++){if(!t.isValidPosition(T,L,0))continue;let A=-1;for(let x=0;x<v.TOTAL_ROWS&&t.isValidPosition(T,L,x);x++)A=x;if(A===-1)continue;const C=this.computeEdgeDistance(T,L),y=this.evaluateMove(t,l,T,L,A,e.type,i);let S=y.score;if(i.randomFactor&&i.randomFactor>0){const x=(Math.random()-.5)*i.randomFactor*50;S+=x}const R={gameOverAfterMove:y.gameOverAfterMove,holes:y.holes,holesCreated:y.holesCreated,blockades:y.blockades,wellSums:y.wellSums,linesCleared:y.linesCleared,aggregateHeight:y.aggregateHeight,bumpiness:y.bumpiness,edgeDistance:C};(i.lexicographic?this.isBetterLexicographic(R,a,!!i.preferEdges):S>s)&&(a=R,s=S,o={x:L,rotation:r,score:S,linesCleared:y.linesCleared,aggregateHeight:y.aggregateHeight,holes:y.holes,holesCreated:y.holesCreated,blockades:y.blockades,bumpiness:y.bumpiness,gameOverAfterMove:y.gameOverAfterMove,edgeDistance:C,wellSums:y.wellSums}),this.traceEnabled&&c.push({x:L,rotation:r,y:A,score:S,linesCleared:y.linesCleared,aggregateHeight:y.aggregateHeight,holes:y.holes,holesCreated:y.holesCreated,blockades:y.blockades,bumpiness:y.bumpiness,gameOverAfterMove:y.gameOverAfterMove,edgeDistance:C,wellSums:y.wellSums})}}if(this.traceEnabled&&o){const r=c.find(T=>T.x===o.x&&T.rotation===o.rotation)??c[0],g=[...c].sort((T,L)=>this.compareCandidates(T,L,i));this.lastTrace={pieceType:e.type,difficultyFlags:{lexicographic:!!i.lexicographic,preferEdges:!!i.preferEdges},weights:i,best:r,top:g.slice(0,this.traceTopK),totalCandidates:c.length}}else this.lastTrace=null;return o}compareCandidates(t,e,i){return i.lexicographic?t.gameOverAfterMove!==e.gameOverAfterMove?t.gameOverAfterMove?1:-1:t.holes!==e.holes?t.holes-e.holes:t.holesCreated!==e.holesCreated?t.holesCreated-e.holesCreated:t.blockades!==e.blockades?t.blockades-e.blockades:t.wellSums!==e.wellSums?t.wellSums-e.wellSums:t.linesCleared!==e.linesCleared?e.linesCleared-t.linesCleared:t.aggregateHeight!==e.aggregateHeight?t.aggregateHeight-e.aggregateHeight:t.bumpiness!==e.bumpiness?t.bumpiness-e.bumpiness:i.preferEdges&&t.edgeDistance!==e.edgeDistance?t.edgeDistance-e.edgeDistance:e.score-t.score:e.score-t.score}isBetterLexicographic(t,e,i){return e?t.gameOverAfterMove!==e.gameOverAfterMove?t.gameOverAfterMove===!1:t.holes!==e.holes?t.holes<e.holes:t.holesCreated!==e.holesCreated?t.holesCreated<e.holesCreated:t.blockades!==e.blockades?t.blockades<e.blockades:t.wellSums!==e.wellSums?t.wellSums<e.wellSums:t.linesCleared!==e.linesCleared?t.linesCleared>e.linesCleared:t.aggregateHeight!==e.aggregateHeight?t.aggregateHeight<e.aggregateHeight:t.bumpiness!==e.bumpiness?t.bumpiness<e.bumpiness:i&&t.edgeDistance!==e.edgeDistance?t.edgeDistance<e.edgeDistance:!1:!0}computeEdgeDistance(t,e){let i=1/0;for(const s of t){const a=e+s.x,o=Math.min(a,v.WIDTH-1-a);o<i&&(i=o)}return i===1/0?0:i}evaluateMove(t,e,i,s,a,o,c){const l=t.clone(),r=B[o]||1;l.lockPiece(i,s,a,r);const g=l.clearLines(),T=l.getAggregateHeight(),L=l.getWellSums(),A=l.countHoles(),C=this.computeHoleMap(l),y=this.countNewHoles(e,C),S=l.countBlockades(),R=l.getBumpiness(),I=l.isGameOver();let x=0;I&&(x-=1e6),x+=T*c.heightWeight,x+=g*c.linesWeight,x+=A*c.holesWeight,x+=S*(c.holesWeight*.5);const $=c.wellsWeight??c.holesWeight*.25;return x+=L*$,x+=R*c.bumpinessWeight,{score:x,linesCleared:g,aggregateHeight:T,holes:A,holesCreated:y,blockades:S,wellSums:L,bumpiness:R,gameOverAfterMove:I}}computeHoleMap(t){const e=Array.from({length:v.TOTAL_ROWS},()=>Array(v.WIDTH).fill(!1));for(let i=0;i<v.WIDTH;i++){let s=!1;for(let a=0;a<v.TOTAL_ROWS;a++)t.data[a][i]!==0?s=!0:s&&(e[a][i]=!0)}return e}countNewHoles(t,e){let i=0;for(let s=0;s<v.TOTAL_ROWS;s++)for(let a=0;a<v.WIDTH;a++)e[s][a]&&!t[s][a]&&i++;return i}}const J={easy:E.EASY,normal:E.NORMAL,hard:E.HARD,god:{...E.GOD,lookahead:2}};class W{static generateLevel(t){let e="easy",i=5,s=500,a,o=3;return t<=10?(e="easy",i=3+Math.floor(t/2),s=800-t*20):t<=30?(e="normal",i=10+Math.floor((t-10)/2),s=600-(t-10)*10):t<=70?(e="hard",i=20+Math.floor((t-30)/2),s=400-(t-30)*5,a=this.generateGarbageGrid(Math.min(10,Math.floor((t-20)/5)))):(e="god",i=40+(t-70),s=200,a=this.generateGarbageGrid(8+Math.floor((t-70)/5))),t>50&&(o=4),t%10===0&&(i+=10),{id:t,name:`Level ${t}`,targetLines:i,aiDifficultyLevel:e,aiWeights:J[e],aiSpeed:Math.max(100,s),initialGrid:a,pieceChoices:o}}static generateGarbageGrid(t){const e=Array.from({length:v.TOTAL_ROWS},()=>Array(v.WIDTH).fill(0)),i=v.TOTAL_ROWS-t;for(let s=i;s<v.TOTAL_ROWS;s++){for(let o=0;o<v.WIDTH;o++)if(Math.random()>.3){const c=Math.floor(Math.random()*7)+1;e[s][o]=c}const a=Math.floor(Math.random()*v.WIDTH);e[s][a]=0}return e}}class K{constructor(t){n(this,"state",0);n(this,"grid");n(this,"renderer");n(this,"ai");n(this,"data");n(this,"currentPiece",null);n(this,"nextPieces",[]);n(this,"activePiecePosition",{x:0,y:0});n(this,"ghostPiecePosition",{x:0,y:0});n(this,"debugHudEnabled",!1);n(this,"versionHudEnabled",!0);n(this,"appVersion","");n(this,"difficultyOverride",null);n(this,"decisionLogVisible",!1);n(this,"lastDecisionLogText","");n(this,"aiTimer",0);n(this,"currentAiSpeed",500);n(this,"moveQueue",[]);n(this,"animationTimer",0);n(this,"lastAiMove",null);n(this,"listeners",{});this.renderer=t,this.grid=new v,this.ai=new Q,this.ai.setTraceEnabled(!0,12),this.data={level:1,linesCleared:0,piecesPlaced:0,targetLines:10,aiDifficulty:E.NORMAL,aiDifficultyLevel:"normal"}}on(t,e){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e)}emit(t,e){this.listeners[t]&&this.listeners[t].forEach(i=>i(e))}setDifficulty(t){this.data.aiDifficulty=E[t],this.data.aiDifficultyLevel=t.toLowerCase();let e=500;switch(t){case"EASY":this.currentAiSpeed=800,e=800;break;case"NORMAL":this.currentAiSpeed=500,e=500;break;case"HARD":this.currentAiSpeed=300,e=300;break;case"GOD":this.currentAiSpeed=200,e=200;break}this.difficultyOverride={level:this.data.aiDifficultyLevel,weights:this.data.aiDifficulty,speedMs:e}}start(t){t?this.loadLevel(t):this.loadLevel(W.generateLevel(1))}loadLevel(t){this.data.level=t.id,this.data.targetLines=t.targetLines,this.difficultyOverride?(this.data.aiDifficulty=this.difficultyOverride.weights,this.data.aiDifficultyLevel=this.difficultyOverride.level,this.currentAiSpeed=this.difficultyOverride.speedMs):(this.data.aiDifficulty=t.aiWeights,this.data.aiDifficultyLevel=t.aiDifficultyLevel,this.currentAiSpeed=t.aiSpeed),this.grid=new v(t.initialGrid),this.data.linesCleared=0,this.data.piecesPlaced=0,this.state=1,this.startTurn(),this.emit("levelLoaded",t)}startTurn(){this.nextPieces=G.createRandomSet(3),this.state=1,this.emit("stateChange",this.state),this.emit("nextPieces",this.nextPieces)}selectPiece(t){this.state===1&&(t<0||t>=this.nextPieces.length||(this.currentPiece=this.nextPieces[t],this.activePiecePosition={x:4,y:0},this.emit("pieceSelected",this.currentPiece),this.state=2,this.aiTimer=0,this.prepareAIMove()))}prepareAIMove(){if(!this.currentPiece)return;const t=this.ai.findBestMove(this.grid,this.currentPiece,this.data.aiDifficulty);t?(this.lastAiMove=t,this.updateDecisionLog(),this.generateMoveQueue(t),this.state=3,this.animationTimer=0):(this.lastAiMove=null,this.updateDecisionLog(),this.state=5,this.emit("gameOver","win"))}updateDecisionLog(){const t=this.ai.getLastTrace();this.lastDecisionLogText=this.formatDecisionLog(t),this.decisionLogVisible&&this.emit("aiTrace",this.lastDecisionLogText)}formatDecisionLog(t){const i=["ReverseTetris AI Trace",`time=${new Date().toISOString()}`,`version=${this.appVersion||"unknown"}`,`difficulty=${this.data.aiDifficultyLevel}`,`turn=${this.data.piecesPlaced+1}`].join(`
`),s=JSON.stringify(this.grid.data);if(!t)return`${i}

(no trace available)

grid=${s}
`;const a=`lexicographic=${t.difficultyFlags.lexicographic} preferEdges=${t.difficultyFlags.preferEdges}`,o=JSON.stringify(t.weights),c=g=>`x=${g.x} r=${g.rotation} y=${g.y} H=${g.holes}(+${g.holesCreated}) B=${g.blockades} W=${g.wellSums} L=${g.linesCleared} AH=${g.aggregateHeight} BU=${g.bumpiness} E=${g.edgeDistance} S=${Math.round(g.score*100)/100}`+(g.gameOverAfterMove?" TOP_OUT":""),l=`best: ${t.pieceType} ${c(t.best)}`,r=t.top.map((g,T)=>`${T+1}. ${t.pieceType} ${c(g)}`).join(`
`);return`${i}
${a}
weights=${o}

${l}

top(${t.top.length}/${t.totalCandidates}):
${r}

grid=${s}
`}generateMoveQueue(t){this.moveQueue=[];let e=t.rotation;for(let a=0;a<e;a++)this.moveQueue.push({type:"rotate",value:1});const s=t.x-4;if(s!==0){const a=s>0?1:-1;for(let o=0;o<Math.abs(s);o++)this.moveQueue.push({type:"move",value:a})}this.moveQueue.push({type:"drop",value:0})}update(t){if(this.state===2&&(this.aiTimer+=t,this.aiTimer>200&&this.prepareAIMove()),this.state===3&&this.currentPiece){this.animationTimer+=t;const e=this.moveQueue.length||1,i=Math.max(30,Math.min(200,this.currentAiSpeed/e));this.animationTimer>=i&&(this.animationTimer=0,this.processAnimationStep())}}processAnimationStep(){var e;if(this.moveQueue.length===0)return;const t=this.moveQueue.shift();t&&(t.type==="rotate"?(e=this.currentPiece)==null||e.rotateClockwise():t.type==="move"?this.activePiecePosition.x+=t.value:t.type==="drop"&&this.executeDropAndLock())}executeDropAndLock(){if(!this.currentPiece)return;const t=this.currentPiece.getBlocks();let e=-1;for(let i=0;i<v.TOTAL_ROWS&&this.grid.isValidPosition(t,this.activePiecePosition.x,i);i++)e=i;if(e!==-1){this.activePiecePosition.y=e;const i=B[this.currentPiece.type];this.grid.lockPiece(t,this.activePiecePosition.x,e,i),this.data.piecesPlaced++;const s=this.grid.clearLines();s>0&&(this.data.linesCleared+=s,this.emit("linesCleared",s)),this.emit("pieceLocked"),this.checkGameStatus()}else this.state=5,this.emit("gameOver","win");this.state===3&&this.startTurn()}checkGameStatus(){if(this.data.linesCleared>=this.data.targetLines){this.state=6,this.emit("gameOver","lose");return}if(this.grid.isGameOver()){this.state=5,this.emit("gameOver","win");return}}render(){var t;if(this.renderer.clear(),this.renderer.drawGrid(this.grid),this.renderer.drawUI(this.data.linesCleared*100,this.data.level,this.data.linesCleared,this.data.targetLines,this.data.aiDifficultyLevel,this.debugHudEnabled?{wellSums:this.grid.getWellSums(),holes:this.grid.countHoles(),blockades:this.grid.countBlockades(),holesCreated:((t=this.lastAiMove)==null?void 0:t.holesCreated)??0,lastMove:this.lastAiMove?{holes:this.lastAiMove.holes,holesCreated:this.lastAiMove.holesCreated,blockades:this.lastAiMove.blockades,wellSums:this.lastAiMove.wellSums,linesCleared:this.lastAiMove.linesCleared,score:this.lastAiMove.score}:void 0}:void 0,this.versionHudEnabled?this.appVersion:void 0),this.state===1)this.renderer.drawPieceSelector(this.nextPieces,-1);else if((this.state===2||this.state===3)&&this.currentPiece){this.renderer.drawPiece(this.currentPiece,this.activePiecePosition.x,this.activePiecePosition.y);const e=this.currentPiece.getBlocks();let i=-1;for(let s=0;s<v.TOTAL_ROWS&&this.grid.isValidPosition(e,this.activePiecePosition.x,s);s++)i=s;i!==-1&&this.renderer.drawGhostPiece(this.currentPiece,this.activePiecePosition.x,i)}this.state===5?this.renderer.drawText("YOU WIN!",300,300,50,"#0f0"):this.state===6&&this.renderer.drawText("GAME OVER",300,300,50,"#f00")}toggleDebugHud(){this.debugHudEnabled=!this.debugHudEnabled}toggleVersionHud(){this.versionHudEnabled=!this.versionHudEnabled}setDecisionLogVisible(t){this.decisionLogVisible=t,t&&this.emit("aiTrace",this.lastDecisionLogText)}getLastDecisionLog(){return this.lastDecisionLogText}}class Z{constructor(t,e){n(this,"canvas");n(this,"renderer");n(this,"listeners",{});this.canvas=t,this.renderer=e,this.setupKeyboardListeners(),this.setupMouseListeners(),this.setupTouchListeners()}on(t,e){this.listeners[t]||(this.listeners[t]=[]),this.listeners[t].push(e)}emit(t,e){this.listeners[t]&&this.listeners[t].forEach(i=>i(e))}setupKeyboardListeners(){window.addEventListener("keydown",t=>{switch(t.key){case"1":this.emit("selectPiece",0);break;case"2":this.emit("selectPiece",1);break;case"3":this.emit("selectPiece",2);break;case"4":this.emit("selectPiece",3);break;case"p":case"P":this.emit("pause");break;case"r":case"R":this.emit("restart");break;case"Escape":this.emit("menu");break;case"d":case"D":this.emit("toggleDebug");break;case"v":case"V":this.emit("toggleVersion");break;case"s":case"S":this.emit("toggleAiLog");break}})}getScaledCoordinates(t,e){const i=this.canvas.getBoundingClientRect();return{x:t-i.left,y:e-i.top}}setupMouseListeners(){this.canvas.addEventListener("mousedown",t=>{const e=this.getScaledCoordinates(t.clientX,t.clientY);this.handlePointerDown(e.x,e.y)}),this.canvas.addEventListener("mousemove",t=>{const e=this.getScaledCoordinates(t.clientX,t.clientY);this.handlePointerMove(e.x,e.y)})}setupTouchListeners(){this.canvas.addEventListener("touchstart",t=>{t.preventDefault();const e=t.touches[0],i=this.getScaledCoordinates(e.clientX,e.clientY);this.handlePointerDown(i.x,i.y)},{passive:!1})}handlePointerDown(t,e){const i=this.renderer.layout;if(console.log("Click:",{x:t,y:e}),console.log("Layout:",{selectionX:i.selectionX,selectionY:i.selectionY,selectionHeight:i.selectionHeight,gridWidth:i.gridWidth,slotWidth:i.slotWidth}),e>=i.selectionY&&e<=i.selectionY+i.selectionHeight&&t>=i.selectionX&&t<=i.selectionX+i.gridWidth){const s=Math.floor((t-i.selectionX)/i.slotWidth);console.log("Hit selection! Index:",s),s>=0&&s<3&&this.emit("selectPiece",s)}}handlePointerMove(t,e){const i=this.renderer.layout;if(e>=i.selectionY&&e<=i.selectionY+i.selectionHeight&&t>=i.selectionX&&t<=i.selectionX+i.gridWidth){const s=Math.floor((t-i.selectionX)/i.slotWidth);if(s>=0&&s<3){this.emit("hoverPiece",s);return}}this.emit("hoverPiece",-1)}}class j{constructor(){n(this,"ctx",null);n(this,"masterGain",null);n(this,"sfxGain",null);n(this,"bgmGain",null);n(this,"isMuted",!1);n(this,"volMaster",.5);n(this,"volSfx",.8);n(this,"volBgm",.4);n(this,"isPlayingBgm",!1);n(this,"bgmNodes",[]);n(this,"bgmTimeout",null)}async init(){if(!this.ctx)try{this.ctx=new(window.AudioContext||window.webkitAudioContext),this.masterGain=this.ctx.createGain(),this.sfxGain=this.ctx.createGain(),this.bgmGain=this.ctx.createGain(),this.masterGain.connect(this.ctx.destination),this.sfxGain.connect(this.masterGain),this.bgmGain.connect(this.masterGain),this.updateVolumes()}catch(t){console.error("Audio init failed",t)}}updateVolumes(){if(!this.masterGain||!this.sfxGain||!this.bgmGain||!this.ctx)return;const t=this.ctx.currentTime;this.masterGain.gain.setValueAtTime(this.isMuted?0:this.volMaster,t),this.sfxGain.gain.setValueAtTime(this.volSfx,t),this.bgmGain.gain.setValueAtTime(this.volBgm,t)}setMute(t){this.isMuted=t,this.updateVolumes()}playSelect(){if(!this.ctx||!this.sfxGain)return;const t=this.ctx.createOscillator(),e=this.ctx.createGain();t.type="square",t.frequency.setValueAtTime(440,this.ctx.currentTime),t.frequency.exponentialRampToValueAtTime(880,this.ctx.currentTime+.1),e.gain.setValueAtTime(.1,this.ctx.currentTime),e.gain.exponentialRampToValueAtTime(.01,this.ctx.currentTime+.1),t.connect(e),e.connect(this.sfxGain),t.start(),t.stop(this.ctx.currentTime+.1)}playDrop(){if(!this.ctx||!this.sfxGain)return;const t=this.ctx.createOscillator(),e=this.ctx.createGain();t.type="triangle",t.frequency.setValueAtTime(150,this.ctx.currentTime),t.frequency.exponentialRampToValueAtTime(50,this.ctx.currentTime+.15),e.gain.setValueAtTime(.3,this.ctx.currentTime),e.gain.exponentialRampToValueAtTime(.01,this.ctx.currentTime+.2),t.connect(e),e.connect(this.sfxGain),t.start(),t.stop(this.ctx.currentTime+.2)}playClear(){if(!this.ctx||!this.sfxGain)return;const t=this.ctx.currentTime;[523.25,659.25,783.99,1046.5].forEach((i,s)=>{if(!this.ctx)return;const a=this.ctx.createOscillator(),o=this.ctx.createGain();a.type="square",a.frequency.setValueAtTime(i,t+s*.05),o.gain.setValueAtTime(.1,t+s*.05),o.gain.exponentialRampToValueAtTime(.01,t+s*.05+.1),a.connect(o),this.sfxGain&&o.connect(this.sfxGain),a.start(t+s*.05),a.stop(t+s*.05+.1)})}playGameOver(t){if(!(!this.ctx||!this.sfxGain))if(t)this.playClear();else{const e=this.ctx.createOscillator(),i=this.ctx.createGain();e.type="sawtooth",e.frequency.setValueAtTime(200,this.ctx.currentTime),e.frequency.linearRampToValueAtTime(50,this.ctx.currentTime+.5),i.gain.setValueAtTime(.2,this.ctx.currentTime),i.gain.linearRampToValueAtTime(.01,this.ctx.currentTime+.5),e.connect(i),i.connect(this.sfxGain),e.start(),e.stop(this.ctx.currentTime+.5)}}toggleBgm(){this.isMuted?(this.setMute(!1),this.isPlayingBgm||this.startBgm()):this.setMute(!0)}isBgmPlaying(){return!this.isMuted}startBgm(){this.ctx&&(this.isPlayingBgm||(this.isPlayingBgm=!0,this.playBGMLoop()))}playBGMLoop(){if(!this.isPlayingBgm||!this.ctx||!this.bgmGain)return;const e=60/128,i=this.ctx.currentTime;[220,277,330].forEach(c=>{if(!this.ctx||!this.bgmGain)return;const l=this.ctx.createOscillator(),r=this.ctx.createGain();l.type="triangle",l.frequency.value=c,r.gain.setValueAtTime(.05,i),r.gain.linearRampToValueAtTime(.05,i+e*7),r.gain.linearRampToValueAtTime(0,i+e*8),l.connect(r),r.connect(this.bgmGain),l.start(i),l.stop(i+e*8),this.bgmNodes.push({osc:l,gain:r})}),[440,523,659,784,659,523,440,392].forEach((c,l)=>{if(!this.ctx||!this.bgmGain)return;const r=this.ctx.createOscillator(),g=this.ctx.createGain();r.type="sine",r.frequency.value=c;const T=i+l*e;g.gain.setValueAtTime(0,T),g.gain.linearRampToValueAtTime(.1,T+.01),g.gain.exponentialRampToValueAtTime(.01,T+e*.5),r.connect(g),g.connect(this.bgmGain),r.start(T),r.stop(T+e*.6),this.bgmNodes.push({osc:r,gain:g})});const o=e*8*1e3;this.bgmNodes=[],this.bgmTimeout=window.setTimeout(()=>{this.isPlayingBgm&&this.playBGMLoop()},o-50)}stopBgm(){this.isPlayingBgm=!1,this.bgmTimeout!==null&&(clearTimeout(this.bgmTimeout),this.bgmTimeout=null),this.bgmNodes.forEach(t=>{try{t.osc.stop(),t.osc.disconnect(),t.gain.disconnect()}catch{}}),this.bgmNodes=[]}}class tt{constructor(){n(this,"overlays",{});n(this,"app");n(this,"aiLogPanel");n(this,"aiLogVisible",!1);n(this,"aiLogTextArea",null);this.app=document.getElementById("app"),this.createOverlays(),this.aiLogPanel=this.createAiLogPanel(),this.show("menu")}createOverlays(){this.overlays.menu=this.createOverlay("menu-overlay",`
            <h1 class="title">REVERSE TETRIS</h1>
            <div class="menu-buttons">
                <button id="btn-start" class="btn primary">START GAME</button>
                <button id="btn-levels" class="btn">LEVELS</button>
                <button id="btn-howto" class="btn">HOW TO PLAY</button>
                <button id="btn-settings" class="btn">SETTINGS</button>
            </div>
            <p class="footer">Feed the AI until it bursts.</p>
        `),this.overlays.howto=this.createOverlay("howto-overlay",`
            <h2>æ¸¸æˆè¯´æ˜</h2>
            <div class="howto-content">
                <p><strong>ç›®æ ‡ï¼š</strong>è®©ç”µè„‘AIçš„æ–¹å—å †ç§¯åˆ°é¡¶éƒ¨ï¼Œä½¿å…¶"é¡¶é£"è€Œè¾“æ‰æ¸¸æˆã€‚</p>
                <p><strong>ç©æ³•ï¼š</strong></p>
                <ul>
                    <li>æ¯å›åˆä»ä¸Šæ–¹3ä¸ªå€™é€‰æ–¹å—ä¸­é€‰æ‹©1ä¸ª</li>
                    <li>ç‚¹å‡»æ–¹å—æˆ–æŒ‰æ•°å­—é”® 1/2/3 é€‰æ‹©</li>
                    <li>ç”µè„‘AIä¼šè‡ªåŠ¨æ”¾ç½®ä½ é€‰çš„æ–¹å—</li>
                    <li>é€‰æ‹©èƒ½è®©AIéš¾ä»¥æ¶ˆè¡Œçš„æ–¹å—</li>
                    <li>ç´¯è®¡æ¶ˆé™¤çš„è¡Œæ•°è¾¾æ ‡å³è¿‡å…³</li>
                </ul>
                <p><strong>æŠ€å·§ï¼š</strong>é€‰æ‹©é•¿æ¡(I)ä¼šå¸®AIæ¶ˆè¡Œï¼Œå°½é‡é€‰æ‹©S/Z/Tç­‰éš¾æ”¾çš„å½¢çŠ¶ï¼</p>
            </div>
            <button id="btn-back-howto" class="btn">BACK</button>
        `),this.overlays.settings=this.createOverlay("settings-overlay",`
            <h2>è®¾ç½®</h2>
            <div class="settings-content">
                <div class="setting-item">
                    <label>ç”µè„‘éš¾åº¦</label>
                    <div class="difficulty-btns">
                        <button id="diff-easy" class="btn diff-btn">ç®€å•</button>
                        <button id="diff-normal" class="btn diff-btn active">æ™®é€š</button>
                        <button id="diff-hard" class="btn diff-btn">å›°éš¾</button>
                        <button id="diff-god" class="btn diff-btn">åœ°ç‹±</button>
                    </div>
                </div>
            </div>
            <button id="btn-back-settings" class="btn">BACK</button>
        `),this.overlays.levels=this.createOverlay("levels-overlay",`
            <h2>SELECT LEVEL</h2>
            <div class="level-grid" id="level-grid">
                <!-- Generated via JS -->
            </div>
            <button id="btn-back-levels" class="btn back">BACK</button>
        `),this.overlays.pause=this.createOverlay("pause-overlay",`
            <h2>PAUSED</h2>
            <button id="btn-resume" class="btn primary">RESUME</button>
            <button id="btn-restart-pause" class="btn">RESTART</button>
            <button id="btn-menu-pause" class="btn">MAIN MENU</button>
        `),this.overlays.win=this.createOverlay("win-overlay",`
            <h1 class="win">VICTORY!</h1>
            <p>The AI Topped Out.</p>
            <button id="btn-next-level" class="btn primary">NEXT LEVEL</button>
            <button id="btn-menu-win" class="btn">MAIN MENU</button>
        `),this.overlays.lose=this.createOverlay("lose-overlay",`
            <h1 class="lose">DEFEAT</h1>
            <p>The AI Survived your attacks.</p>
            <button id="btn-retry" class="btn primary">RETRY</button>
            <button id="btn-menu-lose" class="btn">MAIN MENU</button>
        `);const t=document.createElement("div");t.id="hud-overlay",t.className="overlay hidden",t.style.pointerEvents="none",t.innerHTML=`
            <div class="hud-top">
                <div class="hud-score">Level: <span id="hud-level">1</span></div>
                <div class="hud-target">Target: <span id="hud-target">0</span>/10 Lines</div>
            </div>
        `,this.app.appendChild(t),this.overlays.hud=t}createAiLogPanel(){const t=document.createElement("div");t.id="ai-log-panel",t.className="ai-log-panel hidden",t.innerHTML=`
            <div class="ai-log-header">
                <div class="ai-log-title">AI LOG</div>
                <div class="ai-log-actions">
                    <button id="ai-log-copy" class="ai-log-btn">COPY</button>
                    <button id="ai-log-close" class="ai-log-btn">CLOSE</button>
                </div>
            </div>
            <textarea id="ai-log-text" class="ai-log-text" readonly></textarea>
            <div class="ai-log-hint">Toggle: S</div>
        `,this.app.appendChild(t),this.aiLogTextArea=t.querySelector("#ai-log-text");const e=t.querySelector("#ai-log-copy");e==null||e.addEventListener("click",async()=>{var a;const s=((a=this.aiLogTextArea)==null?void 0:a.value)??"";try{await navigator.clipboard.writeText(s),e.textContent="COPIED",setTimeout(()=>e.textContent="COPY",800)}catch{this.aiLogTextArea&&(this.aiLogTextArea.focus(),this.aiLogTextArea.select())}});const i=t.querySelector("#ai-log-close");return i==null||i.addEventListener("click",()=>this.setAiLogVisible(!1)),t}createOverlay(t,e){const i=document.createElement("div");return i.id=t,i.className="overlay hidden",i.innerHTML=e,this.app.appendChild(i),i}show(t){Object.values(this.overlays).forEach(e=>e.classList.add("hidden")),this.overlays[t]&&this.overlays[t].classList.remove("hidden"),t==="game"&&this.overlays.hud.classList.remove("hidden")}hideAll(){Object.values(this.overlays).forEach(t=>t.classList.add("hidden"))}toggleAiLogPanel(){this.setAiLogVisible(!this.aiLogVisible)}setAiLogVisible(t){this.aiLogVisible=t,t?this.aiLogPanel.classList.remove("hidden"):this.aiLogPanel.classList.add("hidden")}isAiLogVisible(){return this.aiLogVisible}setAiLog(t){this.aiLogTextArea&&(this.aiLogTextArea.value=t,this.aiLogTextArea.scrollTop=this.aiLogTextArea.scrollHeight)}on(t,e,i){const s=document.getElementById(t);s&&s.addEventListener(e,i)}updateHUD(t,e,i){const s=document.getElementById("hud-level"),a=document.getElementById("hud-target");s&&(s.textContent=t.toString()),a&&(a.textContent=e.toString()+"/"+i.toString())}generateLevelGrid(t,e){const i=document.getElementById("level-grid");if(i){i.innerHTML="";for(let s=1;s<=t;s++){const a=document.createElement("button");a.className="level-btn",a.textContent=s.toString(),a.onclick=()=>e(s),i.appendChild(a)}}}}const et=document.querySelector("#app");et.innerHTML=`
  <canvas id="game-canvas" width="800" height="600"></canvas>
  <button id="audio-btn">ğŸ”‡</button>
`;const k=document.getElementById("game-canvas"),b=new q(k),p=new K(b);p.appVersion="v0.0.0+99f06b7";const w=new Z(k,b),m=new j,d=new tt,M=()=>{m.init(),k.removeEventListener("mousedown",M),k.removeEventListener("touchstart",M),window.removeEventListener("keydown",M)};k.addEventListener("mousedown",M);k.addEventListener("touchstart",M);window.addEventListener("keydown",M);const P=document.getElementById("audio-btn");P.addEventListener("click",h=>{h.stopPropagation(),m.init(),m.toggleBgm(),m.isBgmPlaying()?P.textContent="ğŸ”Š":P.textContent="ğŸ”‡"});let O="NORMAL";d.on("btn-start","click",()=>{d.show("game"),p.setDifficulty(O),p.start(),m.playSelect()});d.on("btn-levels","click",()=>{d.generateLevelGrid(20,h=>{d.show("game"),p.setDifficulty(O),p.loadLevel(W.generateLevel(h)),m.playSelect()}),d.show("levels"),m.playSelect()});d.on("btn-howto","click",()=>{d.show("howto"),m.playSelect()});d.on("btn-back-howto","click",()=>{d.show("menu"),m.playSelect()});d.on("btn-settings","click",()=>{d.show("settings"),m.playSelect()});d.on("btn-back-settings","click",()=>{d.show("menu"),m.playSelect()});const D=()=>{document.querySelectorAll(".diff-btn").forEach(t=>t.classList.remove("active"));const h=document.getElementById(`diff-${O.toLowerCase()}`);h&&h.classList.add("active")};d.on("diff-easy","click",()=>{O="EASY",D(),m.playSelect()});d.on("diff-normal","click",()=>{O="NORMAL",D(),m.playSelect()});d.on("diff-hard","click",()=>{O="HARD",D(),m.playSelect()});d.on("diff-god","click",()=>{O="GOD",D(),m.playSelect()});d.on("btn-back-levels","click",()=>{d.show("menu"),m.playSelect()});d.on("btn-resume","click",()=>{d.show("game"),m.playSelect()});d.on("btn-restart-pause","click",()=>{d.show("game"),p.start(W.generateLevel(p.data.level)),m.playSelect()});d.on("btn-menu-pause","click",()=>{d.show("menu"),m.playSelect()});d.on("btn-next-level","click",()=>{const h=p.data.level;p.loadLevel(W.generateLevel(h+1)),d.show("game"),m.playSelect()});d.on("btn-menu-win","click",()=>{d.show("menu"),m.playSelect()});d.on("btn-retry","click",()=>{p.loadLevel(W.generateLevel(p.data.level)),d.show("game"),m.playSelect()});d.on("btn-menu-lose","click",()=>{d.show("menu"),m.playSelect()});w.on("selectPiece",h=>{m.playSelect(),p.selectPiece(h)});w.on("restart",()=>{m.playSelect(),p.start(W.generateLevel(p.data.level))});w.on("pause",()=>{d.show("pause"),m.playSelect()});w.on("menu",()=>{p.state!==0&&(d.show("pause"),m.playSelect())});w.on("toggleDebug",()=>{p.toggleDebugHud()});w.on("toggleVersion",()=>{p.toggleVersionHud()});w.on("toggleAiLog",()=>{d.toggleAiLogPanel(),p.setDecisionLogVisible(d.isAiLogVisible()),d.isAiLogVisible()&&d.setAiLog(p.getLastDecisionLog())});p.on("pieceLocked",()=>{m.playDrop(),b.animator.triggerShake(100)});p.on("linesCleared",h=>{m.playClear(),d.updateHUD(p.data.level,p.data.linesCleared,p.data.targetLines);const t=b.layout.gridX+b.layout.gridWidth/2,e=b.layout.gridY+b.layout.gridHeight/2;b.animator.spawnParticles(t,e,"#ffcc00",20*h),b.animator.spawnText(t,e,`+${h}`,"#fff"),b.animator.triggerShake(300)});p.on("levelLoaded",h=>{d.updateHUD(h.id,0,h.targetLines)});p.on("gameOver",h=>{m.playGameOver(h==="win"),h==="win"?d.show("win"):d.show("lose")});p.on("aiTrace",h=>{d.isAiLogVisible()&&d.setAiLog(h)});let V=0;function _(h){const t=h-V;V=h,p.update(t),p.render(),requestAnimationFrame(_)}requestAnimationFrame(_);
